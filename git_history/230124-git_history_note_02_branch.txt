/////////////////////////////////////////////////////////////////////
// git init
    > 아무 것도 안 한 상태
    > 나머지는 commit 편에서 봤고. 아직 안 봤던 거 중에 HEAD 라는 파일이 있음.
    //>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
        / HEAD
            > ref: refs/heads/master
    //<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

/////////////////////////////////////////////////////////////////////
// git add myFile1.txt
// git commit -m "first commit"
    / 커밋을 새로 한번 해봤다.
    //>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
        / HEAD
            > ref: refs/heads/master
    //<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
    //>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
        / refs/heads/master
            > 53cle6c6e4ebb20~~~a0b56d0
    //<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
    //>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
        /objects/53/cle6c6e4ebb20~~~a0b56d0
            > tree 9f8df35e4932276~~~3fdb37c
            > author egoing <egoing@gmail.com> 1487294517 +0900
            > committer egoing <egoing@gmail.com> 1487294517 +0900
            > first commit
    //<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
    //>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
        /
    //<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
    //>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
        /
    //<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
    //>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
        /
    //<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

    > 커밋을 했더니 "HEAD" 라는 파일이 생김.
    > 그 "HEAD" 라는 파일 안에 들어 있는 내용은 "ref: refs/heads/master" 임.
    > 파일 안에서 "ref" 속성이 가리키고 있는 디렉토리 "refs/heads/master"를 찾아가 봄.
    > "refs/heads/master" 안에를 들여다 보니까 object 의 id 만 달랑 하나 있음.
    > "53cle6c6e4ebb20~~~a0b56d0"
    > 그 object id 로 찾아가 보니까 커밋 ojbect 였고, 커밋 정보가 들어 있음.
    > "HEAD" 파일에는 "refs/heads/master" 라는 디렉토리가 있었고, 
    그 디렉토리 안에는 "53cle6c6e4ebb20~~~a0b56d0" 라는 object id 가 있었고, 
    그 object 안에는 방금 만든 커밋 이력이 있었음.


/////////////////////////////////////////////////////////////////////
// git commit -am "second commit"
    / "myFile1.txt" 를 조금 수정해서 새로운 커밋을 하나 더 만들어 봤다.
    //>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
        / HEAD
            > ref: refs/heads/master
    //<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
    //>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
        / refs/heads/master
            > 70583f04e32bec98d3dd~~~d39a409
    //<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
    //>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
        /objects/53/cle6c6e4ebb20~~~a0b56d0
            > tree 9f8df35e4932276~~~3fdb37c
            > author egoing <egoing@gmail.com> 1487294517 +0900
            > committer egoing <egoing@gmail.com> 1487294517 +0900
            > first commit
    ----------------------------------------------------
        /objects/70/583f04e32bec98d3dd~~~d39a409
            > tree 36f609fa71850be13~~~8e7057c
            > author egoing <egoing@gmail.com> 1487294612 +0900
            > committer egoing <egoing@gmail.com> 1487294612 +0900
            > seconde commit
    //<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
    
    > 커밋을 하면 "HEAD" 라는 파일이 만들어짐.
    > "HEAD" 라는 파일 안에는 "refs/heads/" 디렉토리 안에 있는 "master" 라는 파일을 가리킴.
    > "master" 파일 안에는 가장 마지막에 커밋한 object 의 id 를 들고 있음.
    > 결국 git 에서 branch 라는 시스템은 "refs/heads/" 디렉토리 안에서 어떤 파일을 가리킬지를 의미하는 게 아닐까.


/////////////////////////////////////////////////////////////////////
// git branch exp 
    / "exp" 라는 새로운 브랜치를 하나 만들어 보자. (experimental 약자)
    //>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
        / refs/heads/master
            > 70583f04e32bec98d3dd~~~d39a409
    ----------------------------------------------------
        / refs/heads/master
            > 70583f04e32bec98d3dd~~~d39a409
        / refs/heads/exp
            > 70583f04e32bec98d3dd~~~d39a409
    //<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
    
    > "exp"새로운 브랜치를 하나 만들었다.
    > "refs/heads/" 디렉토리 안에 "exp" 라는 파일이 새로 생겼다.
    > "exp" 파일 안에는 "master" 파일과 똑같은 object 의 id 를 담고 있다.
    > 이 object 는 최신 커밋 정보다.
    > 이 최신 커밋 object 를 바탕으로 해서 "exp" 라는 branch 를 새로 만든 것.


/////////////////////////////////////////////////////////////////////
// git checkout exp
    / "exp" 라는 새로운 브랜치를 하나 만들어 보자. (experimental 약자)
    //>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
        / HEAD
            > ref: refs/heads/exp
    //<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
    > "exp" 라는 브랜치로 checkout 해봤다.
    > "HEAD" 파일이 가리키는 디렉토리 정보가 "refs/heads/master" 에서 "refs/heads/exp" 로 바꼈다.


/////////////////////////////////////////////////////////////////////
// git commit -am "created myFile2.txt"
    / "myFile2.txt" 라는 파일을 새로 만들어서 추가하고 커밋해 봤다.
    //>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
        / HEAD
            > ref: refs/heads/exp
    //<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
    //>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
        / refs/heads/exp
            > 40d5baabb3fc1fb6449e~~~e95e936
    //<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
    //>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
        / objects/40/d5baabb3fc1fb6449e~~~e95e936
            > tree 769a8040f07a85bb8d~~~98ddfb1
            > parent 70583f04e32bec98d3dd~~~d39a409
            > author egoing <egoing@gmail.com> 1487299484 +0900
            > committer egoing <egoing@gmail.com> 1487299484 +0900
            > third commit
    //<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

    > "HEAD" 파일은 그대로 "refs/heads/exp" 파일을 가리키고 있고.
    > 대신 "refs/heads/exp" 파일이 가리키고 있던 커밋 object 의 id 가 바뀜.
    > object id 는 가장 최신 커밋 정보를 들고 있는 object 의 id 로 바뀜.


/////////////////////////////////////////////////////////////////////
// git checkout master
    / 다른 거 다 그대로 두고 branch 만 "master" 로 checkout 해봤다.
    //>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
        / HEAD
            > ref: refs/heads/master
    //<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

    > "HEAD" 파일만 바뀜. 다른 건 바뀐 게 하나도 없음. 
    > "refs/heads/exp" 에서 "refs/heads/master" 로만 바뀜.
    > "refs/heads/" 디렉토리 안에 있던 "master" 라는 파일은 바뀌는 게 없음.
    > "master" 브랜치 안에서는 최신 커밋이 아직 변함이 없으니까.
    > 우리가 아까 커밋한 거는 "exp" branch 안에서만 일어난 일이니까.
    > 자, 결국 branch 라는 것은 파일 이름들이다.
    > 어디에 있는 파일 이름들이다? "refs/heads/" 디렉토리 안에 있는 파일들의 이름들이다.
    > "refs/heads/" 디렉토리 안에 있는 파일들은 각각 가장 최신 커밋이 무엇인지 커밋 object 의 id 를 가리키고 있다.
    > 현재 어떤 branch 를 활성화하고 있는가는 "HEAD" 파일 안에 "refs/heads/master" 이런 식으로 branch 파일을 가리키고 있다.

/////////////////////////////////////////////////////////////////////
// git checkout master
// git merge exp
    / 자 이제 보자. 병합할 때는 여러 가지 경우가 있어.
        1. master 와 exp 사이에 겹치지 않는 새로운 파일.
        2. master 와 exp 모두에서 동시에 존재하는 파일이지만 서로 다른 부분을 수정한 경우.
        3. master 와 exp 모두에서 동시에 존재하는 파일이면서 서로 같은 부분을 수정한 경우.
    / 여기서 1번이랑 2번은 아주 행복한 경우야. 딱히 우리가 뭔갈 하지 않아도 알아서 자동으로 병합해 줌.
    / 불행은 3번에서 시작되지.
    //>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
        / commonFile.txt
            > function b() { }
            > <<<<<<<< HEAD
            > function a(master) { }
            > ========
            > function a(exp) { }
            > >>>>>>>> exp
            > function c() { }
    //<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

    > 이런 모양이 되었다고 할 때, git 에서는 충돌난 부분을 <<<< HEAD >>>> EXP 이런 걸로 알려줌.
    > 자기가 자동으로 merge 해보려고 했으나, 실패한 부분에서 이거 너가 좀 해달라고 우리한테 위임하는 것.
    > <<<<<<<< HEAD 이 부분이 현재 checkout 한 branch. 
    > >>>>>>>> exp 이 부분이 "exp" 라는 branch 로부터 들여오려고 했던 부분.
    > 대처 방법은?
    > 해당 부분을 수동으로 수정함.
    > git add commonFile.txt 
    > 수동으로 add 해주고
    > git commit -m "resolved conflict"
    > 다시 commit 해줌.
    
    / 자동 병합에 대해 생각해 보자.
        > "master" 라는 branch 가 있음.
        > 이 branch 의 최신 커밋은 "123" 임.
        > 여기서 "exp" 라는 branch 를 새로 만듦.
        > "master" 에서는 "456" 이라는 커밋을 했고, "exp" 에서는 "789" 라는 커밋을 했음.
        > "master" 는 "123" > "456" / "exp" 는 "123" > "789"
        > 여기서 merge 를 해볼까? 그러면 "456" 에도 snapshot 이 있고, "789" 에도 snapshot 이 있겠지.
        > snapshot 은 tree object 가 들고 있을 거야. 파일과 blob object 를 맵핑해놓았겠지.
        > 이제 각 파일마다 맵핑되어 있는 blob object 의 id 를 비교해서 id 가 같은 파일은 그냥 안 건드려도 됨.
        > 문제는 파일에 맵핑되어 있는 object id 가 다른 경우.
        > 이때는 파일 내용을 비교해 보고 서로 다른 부분을 수정했으면 git 이 알아서 서로 비껴가도록 합쳐서 수정해 줌. 그러고 새로운 blob object 를 만들겠지.
        > 근데 또 같은 경우를 수정했을 때는 자기도 어쩔 수가 없다고. 
        > 이거 수정된 부분을 "master" 에 있는 내용을 그대로 둬야 하는지, "exp" 에 있는 내용을 가지고 와야 하는지, 지가 뭔데 멋대로 판단해.
        > 이때는 에라 모르겠다 하고 사람한테 맡겨버림. 그게 '충돌'이라는 것.

    / fast-forward 에 대해 생각해 보자.
        > 자동 병합이라는 것도 필요 없는 경우가 있음.
        > "master" 라는 branch 가 있음.
        > 이 branch 의 최신 커밋은 "123" 임.
        > 여기서 "exp" 라는 branch 를 새로 만듦.
        > "exp" 에서 "456" 이라는 커밋을 만듦.
        > 이대로 "master" 로 checkout 해서 "exp" 를 병합하려고 함.
        > "master" 는 "123" 이고 "exp" 는 "123" > "456" 임.
        > 그러면 그냥 뭐 새로운 거 만들 필요도 없이, "master" 에 있던 "HEAD" 정보를 "123" 에서 "456" 으로 옮기기만 하면 됨.
        > 새로운 커밋이 만들어지지도 않음.
        > 이게 fast-forward 병합인데, 이런 경우가 아닌 recursive 병합은 새로운 커밋이 만들어짐.
        > "master" 랑 "exp" 랑 병합했어요~ 라는 이력을 남기면서 merge commit 이 새로 만들어짐.